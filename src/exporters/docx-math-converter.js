import { convertToXmlComponent } from 'docx';
import { mathjax } from 'mathjax-full/js/mathjax.js';
import { TeX } from 'mathjax-full/js/input/tex.js';
import { AllPackages } from 'mathjax-full/js/input/tex/AllPackages.js';
import { liteAdaptor } from 'mathjax-full/js/adaptors/liteAdaptor.js';
import { RegisterHTMLHandler } from 'mathjax-full/js/handlers/html.js';
import { SerializedMmlVisitor } from 'mathjax-full/js/core/MmlTree/SerializedMmlVisitor.js';
import { STATE } from 'mathjax-full/js/core/MathItem.js';
import { mml2omml } from 'mathml2omml';
import { xml2js } from 'xml-js';

let mathJaxEnvironment = null;
let mathJaxInitializing = null;

// Exclude bussproofs because it requires layout features that depend on typesetting output jax.
const TEX_PACKAGES = AllPackages.filter((pkg) => pkg !== 'bussproofs');

// Unicode space characters for LaTeX spacing commands
const UNICODE_SPACES = {
  EM_SPACE: '\u2003', // 1em space (for \quad)
  TWO_EM_SPACE: '\u2003\u2003', // 2em space (for \qquad)
  THIN_SPACE: '\u2009', // thin space (for \,)
  MEDIUM_SPACE: '\u2005', // medium space (for \:)
  THICK_SPACE: '\u2004', // thick space (for \;)
  NEGATIVE_THIN_SPACE: '', // negative thin space (for \!) - no unicode equivalent, use empty
  EN_SPACE: '\u2002', // en space
};

// LaTeX commands that MathJax doesn't support, mapped to Unicode characters
// These are typically from packages like esint, stmaryrd, etc.
const UNSUPPORTED_LATEX_COMMANDS = {
  // Integral variants (esint package)
  '\\oiint': '\u222F', // ∯ surface integral
  '\\oiiint': '\u2230', // ∰ volume integral
  '\\varointclockwise': '\u2232', // ∲ clockwise contour integral
  '\\ointctrclockwise': '\u2233', // ∳ anticlockwise contour integral
  '\\intclockwise': '\u2231', // ∱ clockwise integral

  // Additional symbols that might not be supported
  '\\amalg': '\u2A3F', // ⨿ amalgamation
};

/**
 * Preprocess LaTeX string to replace unsupported commands with Unicode equivalents.
 * This allows commands from packages like esint to work without MathJax support.
 */
function preprocessLatexCommands(latexString) {
  let result = latexString;
  for (const [command, unicode] of Object.entries(UNSUPPORTED_LATEX_COMMANDS)) {
    // Use regex to match the command (with word boundary to avoid partial matches)
    const regex = new RegExp(command.replace(/\\/g, '\\\\') + '(?![a-zA-Z])', 'g');
    result = result.replace(regex, unicode);
  }
  return result;
}

// MathML named space values (approximate em values)
const MATHML_NAMED_SPACES = {
  veryverythinmathspace: 0.056, // 1/18 em
  verythinmathspace: 0.111, // 2/18 em
  thinmathspace: 0.167, // 3/18 em
  mediummathspace: 0.222, // 4/18 em
  thickmathspace: 0.278, // 5/18 em
  verythickmathspace: 0.333, // 6/18 em
  veryverythickmathspace: 0.389, // 7/18 em
};

// Placeholder markers for spaces (will be replaced after OMML conversion)
const SPACE_PLACEHOLDER_PREFIX = '\uFFF0SPACE_';
const SPACE_PLACEHOLDER_SUFFIX = '_SPACE\uFFF0';

/**
 * Convert a space value (em, named, etc.) to Unicode space character.
 */
function spaceValueToUnicode(value) {
  if (!value) return '';

  let emValue = 0;

  // Check if it's a named space
  if (MATHML_NAMED_SPACES[value] !== undefined) {
    emValue = MATHML_NAMED_SPACES[value];
  } else {
    // Try to parse as numeric value
    const numMatch = value.match(/^(-?[\d.]+)(em|pt|px)?$/);
    if (numMatch) {
      emValue = parseFloat(numMatch[1]);
      const unit = numMatch[2] || 'em';
      // Convert pt/px to approximate em (assuming 1em ≈ 10pt)
      if (unit === 'pt') emValue = emValue / 10;
      else if (unit === 'px') emValue = emValue / 16;
    }
  }

  // Map em value to Unicode space
  if (emValue >= 1.8) {
    return UNICODE_SPACES.TWO_EM_SPACE; // \qquad (2em)
  } else if (emValue >= 0.8) {
    return UNICODE_SPACES.EM_SPACE; // \quad (1em)
  } else if (emValue >= 0.25) {
    return UNICODE_SPACES.THICK_SPACE; // \; (5/18 em ≈ 0.278em), thickmathspace
  } else if (emValue >= 0.19) {
    return UNICODE_SPACES.MEDIUM_SPACE; // \: (4/18 em ≈ 0.222em), mediummathspace
  } else if (emValue > 0) {
    return UNICODE_SPACES.THIN_SPACE; // \, (3/18 em ≈ 0.167em), thinmathspace
  }

  return '';
}

// Placeholder for zero-width space (used for empty mrow elements)
const ZWSP_PLACEHOLDER = '\uFFF1ZWSP\uFFF1';
const ZERO_WIDTH_SPACE = '\u200B';

/**
 * Replace empty <mrow> elements with a placeholder to avoid empty placeholder boxes in Word.
 * Empty mrow elements are generated by LaTeX empty groups like {} in expressions such as:
 * - {}_a^b X (prescripts)
 * - {}^{14}_6 C (isotopes)
 * - x^2{}^3 (consecutive superscripts)
 * 
 * We use a placeholder because mml2omml strips zero-width spaces from mtext elements.
 * The placeholder will be replaced with actual zero-width space after OMML conversion.
 */
function preprocessEmptyMrow(mathMlString) {
  // Match empty mrow elements (with optional attributes like data-mjx-texclass)
  // Replace with mrow containing a placeholder that will survive mml2omml conversion
  return mathMlString.replace(
    /<mrow([^>]*)>\s*<\/mrow>/g,
    `<mrow$1><mtext>${ZWSP_PLACEHOLDER}</mtext></mrow>`
  );
}

/**
 * Replace zero-width space placeholders in OMML string with actual zero-width spaces.
 */
function postprocessEmptyMrow(ommlString) {
  return ommlString.replace(new RegExp(ZWSP_PLACEHOLDER, 'g'), ZERO_WIDTH_SPACE);
}

/**
 * Convert MathML mspace elements and mo lspace/rspace attributes to placeholders.
 * The markers will be replaced with actual Unicode spaces after OMML conversion,
 * because mml2omml strips whitespace-only content from mtext elements.
 */
function preprocessMathMlSpaces(mathMlString) {
  let placeholderIndex = 0;
  const spacePlaceholders = new Map();

  function createPlaceholder(spaces) {
    if (!spaces) return '';
    const placeholder = `${SPACE_PLACEHOLDER_PREFIX}${placeholderIndex}${SPACE_PLACEHOLDER_SUFFIX}`;
    spacePlaceholders.set(placeholder, spaces);
    placeholderIndex++;
    return placeholder;
  }

  // Step 1: Process <mspace width="..."> elements
  let processed = mathMlString.replace(
    /<mspace\s+width="([^"]+)"(?:\s*\/)?>(?:<\/mspace>)?/g,
    (match, width) => {
      const spaces = spaceValueToUnicode(width);
      if (spaces) {
        return `<mtext>${createPlaceholder(spaces)}</mtext>`;
      }
      return '';
    }
  );

  // Step 2: Process <mo lspace="..." rspace="..."> elements
  // This handles \bmod which uses <mo lspace="thickmathspace" rspace="thickmathspace">
  processed = processed.replace(
    /<mo([^>]*)\slspace="([^"]+)"([^>]*)>/g,
    (match, before, lspace, after) => {
      const spaces = spaceValueToUnicode(lspace);
      if (spaces) {
        const placeholder = createPlaceholder(spaces);
        // Insert mtext before mo and remove lspace attribute
        return `<mtext>${placeholder}</mtext><mo${before}${after}>`;
      }
      return match;
    }
  );

  processed = processed.replace(
    /<\/mo>(\s*)(?=<(?!mtext))/g,
    (match, whitespace) => {
      // Check if the preceding mo had rspace - we need to look back
      return match;
    }
  );

  // More robust approach: handle rspace by looking for mo elements with rspace
  processed = processed.replace(
    /<mo([^>]*)\srspace="([^"]+)"([^>]*)>([^<]*)<\/mo>/g,
    (match, before, rspace, after, content) => {
      const spaces = spaceValueToUnicode(rspace);
      if (spaces) {
        const placeholder = createPlaceholder(spaces);
        // Remove rspace attribute and add mtext after mo
        const cleanedBefore = before.replace(/\slspace="[^"]*"/, '');
        const cleanedAfter = after.replace(/\slspace="[^"]*"/, '');
        return `<mo${cleanedBefore}${cleanedAfter}>${content}</mo><mtext>${placeholder}</mtext>`;
      }
      return match;
    }
  );

  // Step 3: Process invisible operators that should have some spacing
  // &#x2061; (U+2061) is "function application" - used after \log, \sin, \cos, etc.
  // In DOCX, this needs a thin space to separate function name from argument
  processed = processed.replace(
    /<mo[^>]*>&#x2061;<\/mo>/g,
    () => {
      const placeholder = createPlaceholder(UNICODE_SPACES.THIN_SPACE);
      return `<mtext>${placeholder}</mtext>`;
    }
  );

  // Also handle the actual Unicode character U+2061 if it appears directly
  processed = processed.replace(
    /<mo[^>]*>\u2061<\/mo>/g,
    () => {
      const placeholder = createPlaceholder(UNICODE_SPACES.THIN_SPACE);
      return `<mtext>${placeholder}</mtext>`;
    }
  );

  // Step 4: Process movablelimits operators (sup, inf, max, min, lim, etc.)
  // These operators need a thin space after them when followed by an argument
  // MathML: <mo movablelimits="true">sup</mo><mi>S</mi>
  // Should become: sup + space + S
  processed = processed.replace(
    /<mo[^>]*movablelimits="true"[^>]*>([^<]+)<\/mo>(\s*)(?=<mi)/g,
    (match, content, whitespace) => {
      const placeholder = createPlaceholder(UNICODE_SPACES.THIN_SPACE);
      return `<mo>${content}</mo><mtext>${placeholder}</mtext>${whitespace}`;
    }
  );

  return { processed, spacePlaceholders };
}

/**
 * Replace space placeholders in OMML string with actual Unicode spaces.
 */
function postprocessOmmlSpaces(ommlString, spacePlaceholders) {
  let result = ommlString;
  for (const [placeholder, spaces] of spacePlaceholders) {
    result = result.replace(new RegExp(placeholder, 'g'), spaces);
  }
  return result;
}

/**
 * Extract column alignment info from MathML mtable elements.
 * Returns an array of alignment objects, one for each mtable found.
 * Each alignment value can be 'left', 'center', or 'right'.
 */
function extractColumnAlignments(mathMlString) {
  const alignments = [];
  const mtableRegex = /<mtable[^>]*\scolumnalign="([^"]+)"[^>]*>/g;
  let match;
  while ((match = mtableRegex.exec(mathMlString)) !== null) {
    // columnalign can be space-separated values like "right left" or "center center center"
    const alignValues = match[1].trim().split(/\s+/);
    alignments.push(alignValues);
  }
  return alignments;
}

/**
 * Fix column alignments in OMML output.
 * The mml2omml library hardcodes 'center' for all columns, but we need to respect
 * the columnalign attribute from MathML for aligned equations.
 */
function postprocessColumnAlignments(ommlString, columnAlignments) {
  if (!columnAlignments || columnAlignments.length === 0) {
    return ommlString;
  }

  let alignmentIndex = 0;

  // Find each <m:mcs> block and replace it with the correct alignment structure
  return ommlString.replace(/<m:mcs>[\s\S]*?<\/m:mcs>/g, (mcsBlock) => {
    const alignValues = columnAlignments[alignmentIndex];
    alignmentIndex++;

    if (!alignValues || alignValues.length === 0) {
      return mcsBlock;
    }

    // Build new m:mcs structure with individual m:mc elements for each column
    const mcElements = alignValues.map((align) => {
      // Map MathML alignment values to OMML values
      const ommlAlign = align === 'right' ? 'right' : align === 'left' ? 'left' : 'center';
      return `<m:mc><m:mcPr><m:count m:val="1"/><m:mcJc m:val="${ommlAlign}"/></m:mcPr></m:mc>`;
    });

    return `<m:mcs>${mcElements.join('')}</m:mcs>`;
  });
}

export function convertMathMl2Omml(mathMlString) {
  // Extract column alignments before preprocessing
  const columnAlignments = extractColumnAlignments(mathMlString);
  // Preprocess empty mrow elements to avoid empty placeholder boxes
  let processed = preprocessEmptyMrow(mathMlString);
  // Preprocess mspace elements before conversion
  const { processed: spacesProcessed, spacePlaceholders } = preprocessMathMlSpaces(processed);
  let omml = mml2omml(spacesProcessed, { disableDecode: true });
  // Postprocess to replace placeholders with actual spaces
  omml = postprocessOmmlSpaces(omml, spacePlaceholders);
  // Postprocess to replace empty mrow placeholders with zero-width spaces
  omml = postprocessEmptyMrow(omml);
  // Postprocess to fix column alignments in tables
  omml = postprocessColumnAlignments(omml, columnAlignments);
  return omml;
}

function convertOmml2Math(ommlString) {
  const parsed = xml2js(ommlString, {
    compact: false,
    ignoreDeclaration: true,
    ignoreComment: true,
    captureSpacesBetweenElements: true,
  });

  const elements = parsed?.elements ?? [];
  const mathElement = elements.find((element) => element.type === 'element' && element.name === 'm:oMath');

  if (!mathElement) {
    throw new Error('Invalid OMML content: missing m:oMath element');
  }

  const component = convertToXmlComponent(mathElement);

  if (!component || component.rootKey !== 'm:oMath') {
    throw new Error('Failed to convert OMML element');
  }

  return component;
}

function convertMathMl2Math(mathMlString) {
  const ommlString = convertMathMl2Omml(mathMlString);
  return convertOmml2Math(ommlString);
}

function ensureMathJaxEnvironment() {
  if (mathJaxEnvironment) {
    return mathJaxEnvironment;
  }

  const adaptor = liteAdaptor();
  RegisterHTMLHandler(adaptor);

  const tex = new TeX({ packages: TEX_PACKAGES });
  const document = mathjax.document('', {
    InputJax: tex,
  });

  const visitor = new SerializedMmlVisitor();

  mathJaxEnvironment = { adaptor, document, visitor };
  return mathJaxEnvironment;
}

export async function mathJaxReady() {
  if (mathJaxEnvironment) {
    return true;
  }

  if (mathJaxInitializing) {
    await mathJaxInitializing;
    return true;
  }

  mathJaxInitializing = Promise.resolve().then(() => {
    ensureMathJaxEnvironment();
  });

  await mathJaxInitializing;
  mathJaxInitializing = null;
  return true;
}

function latex2MathMl(latexString) {
  if (typeof latexString !== 'string') {
    throw new Error('latex2MathMl expects a string input');
  }

  // Preprocess unsupported LaTeX commands to Unicode equivalents
  const preprocessed = preprocessLatexCommands(latexString);

  const { document, visitor } = ensureMathJaxEnvironment();
  const mathNode = document.convert(preprocessed, {
    display: false,
    end: STATE.CONVERT,
  });

  return visitor.visitTree(mathNode);
}

export function convertLatex2Math(latexString) {
  const mathMlString = latex2MathMl(latexString);
  return convertMathMl2Math(mathMlString);
}

export { convertMathMl2Math, convertOmml2Math };
